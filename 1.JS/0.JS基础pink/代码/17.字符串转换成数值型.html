<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        /* 
        为啥要类型转换
        两种：显式转换  隐式转换

为啥需要类型转换？？  通俗来说，就是把一种数据类型的变量转换成我们需要的数据类型。
  因为：
        JavaScript是弱数据类型: JavaScript也不知道变量到底属于那种数据类型，
        只有赋值了才清楚。
        坑:使用表单、prompt获取过来的数据默认是字符串类型的，
        此时就不能直接简单的进行加法运算。


        1.隐式转换
某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换。
规则:
+号两边只要有一个是字符串，都会把另外一个转成字符串
除了+以外的算术运算符比如–/*等都会把数据转成数字类型
缺点:
转换类型不明确，靠经验才能总结
小技巧:
 +号作为正号解析可以转换成Number




        *//*
        let num = prompt('请输入一个数')
        console.log(num, typeof num);
        //xx,string

*/
        //   / * - 把字符串的10转换成数字型10

        console.log('你' + 18)//你18
        console.log(10 + '10')//1010
        console.log(10 - '10')//0

        console.log(+'10');//数字型10
        console.log(-'10');//数字型-10

        console.log(10 + +'10');//数字型20

        console.log(11+11);//22
        console.log('11'+11);//1111
        console.log(11-11);//0
        console.log('11'-11);//0
        console.log(1*1);//1
        console.log('1'*1);//1
        console.log(typeof '123');//string
        console.log(typeof + '123');//number
        console.log(+'11'+11);//22
 
    

        //2.显式转换
/*
 编写程序时过度依靠系统内部的隐式转换是不严禁的，因为隐式转换规律并不清晰，
 大多是靠经验总结的规律为了避免因隐式转换带来的问题，
 通常根逻辑需要对数据进行显示转换。
 概念:
  自己写代码告诉系统该转成什么类型


parseInt可以解析0x(16进制)和0(8进制)，而且有第二参数可用，指定转换出来的进制
具体细节可以看另外一个js文档


 （1） Number（数据）
  转换为数字型
  如果字符串内容里有非数字，转换失败结果为Nan(not a number)即不是一个数字
  Nan也是数字类型number，代表非数字的数字型
*/

console.log(Number('10'));//数字型10

/*
  （2）parseInt（数据） 
  只保留整数
  不会四舍五入 只会截取小数点前的整数
  p别大写
  会过滤后面的非数字 适合过滤单位 100px 之类的
  */
console.log(parseInt(10.111));//10
console.log(parseInt(10.999));//10
console.log(parseInt('10.111'));//10
console.log(parseInt('10.999'));//10

console.log(parseInt('123abc456'));//123
console.log(parseInt('abc456'));//Nan
console.log(parseInt('123abc'));//123
 

/*
  （3）parseFloat（数据）
  可以保留小数
*/
console.log(parseFloat('10.999'));//10.999

//用Number转换是10.01 parseInt也是 那么有啥区别呢
console.log(Number('10.01'));// 10.01
console.log(parseFloat('10.01'));// 10.01

// 区别
//Number 比较挑 只能放数字类的字符 不能放abc这样的 否则返回NaN
//parseFloat 不挑 而且他经常用于过滤单位之类的
console.log(Number('10.01abc'));//Nan
console.log(parseFloat('10.01abc'));//10.01
console.log(parseFloat('100px'));//100


console.log( parseFloat("1.2345e3"));//1因为识别不了小数点
        console.log( parseInt("1.2345e3"));//1234.5
      
    </script>
</body>

</html>